\begin{comment}



\section{Background and Related Research} \label{sec:background}

\paragraph{Real-Time Systems.} RTS are defined by their strong timing requirements. Some of the common properties and assumptions related to RTS are as follows: 
\ca implemented as a system of periodic tasks, 
\cb worst-case bounds are known for most loops as well as the critical pieces of code, 
%\ciii no dynamically loaded or self-modifying code, 
%\civ recursion is either not used or statically bounded, and
\cc scheduled by priority-driven schemes, and
\cd limited resources (\eg processor, memory, energy). %and
%\cvi stringent timing and safety requirements. 
%The concept of tasks in RTS can be trivially mapped with \textit{processes} or \textit{threads} in general-purpose operating systems (OS).   
%The \textit{scheduler} uses timers and interrupt handlers to enforce timing guarantees
%at runtime. 
%This ability of the scheduler to interrupt application processing at precise time instants is essential to ensure the ``correctness'' of the system. 
Each real-time task $\tau_i$  is characterized by $(T_i, C_i, D_i)$ in which $T_i$ is the period (inter-arrival time), $C_i$ is the constant upper bound on the execution time, 
%called worst case execution time (WCET), 
and $D_i$ is the timing constraint (deadline). 
%Tasks in real-time systems are generally characterized by their periods (inter-arrival times), constant, upper bounded execution times,
%%, called worst case execution time (WCET) 
%and temporal constraints (deadlines).
In multicore systems, task scheduling can be viewed as solving an allocation problem 
%(\ie on which processor a task should execute) 
depending on design criteria such as~\cite{mutiprocessor_survey}: \ca \textit{no migration} (tasks are allocated to a fixed core), \cb \textit{task-level migration} (the jobs of a task may execute on different cores), and \cc \textit{job-level migration} (the jobs of a task migrate to and execute on different core although parallel execution of a job is not permitted). Schedulability tests\cite{res_time_1, res_time_rts,  bini2004schedulability,mutiprocessor_survey} are used to determine
if all tasks in the system meet their respective deadlines. If this is the
case, then the task set is deemed to be \textit{``schedulable''} and the system, \textit{safe}.



%\subsection{State-of-the-art}

\paragraph{Related Work.}

Researchers proposed architectural frameworks~\cite{securecore, mohan_s3a, slack_cornell} that use hardware/software mechanisms to
protect against security vulnerabilities. However, those frameworks require custom hardware-support for monitoring, and hence not suitable for legacy or off-the-shelf systems. Integrating monitoring and detection tasks for multicore RTS without custom hardware support is an open research problem. 



%\paragraph{Other Related Research.}

\end{comment}

\section{Background and Related Work} \label{sec:background}




\paragraph{Real-Time Systems (RTS).} 
Embedded cyber-physical systems with real-time properties are defined by their substantial timing requirements. Some of the common properties and assumptions related to RTS are as follows: 
\ca implemented as a system of periodic tasks, 
\cb worst-case bounds are known for most loops as well as the critical pieces of code, 
%\ciii no dynamically loaded or self-modifying code, 
%\civ recursion is either not used or statically bounded, and
\cc scheduled by priority-driven schemes, and
\cd limited resources (\eg processor, memory, energy). %and
%\cvi stringent timing and safety requirements. 
%The concept of tasks in RTS can be trivially mapped with \textit{processes} or \textit{threads} in general-purpose operating systems (OS).   
%The \textit{scheduler} uses timers and interrupt handlers to enforce timing guarantees
%at runtime. 
%This ability of the scheduler to interrupt application processing at precise time instants is essential to ensure the ``correctness'' of the system. 
Each real-time task $\tau_i$  is characterized by $(T_i, C_i, D_i)$ in which $T_i$ is the period (inter-arrival time), $C_i$ is the constant upper bound on the execution time, 
%called worst case execution time (WCET), 
and $D_i$ is the timing constraint (deadline). 
%Tasks in real-time systems are generally characterized by their periods (inter-arrival times), constant, upper bounded execution times,
%%, called worst case execution time (WCET) 
%and temporal constraints (deadlines).
In multicore systems, task scheduling can be viewed as solving an allocation problem 
%(\ie on which processor a task should execute) 
depending on design criteria such as~\cite{mutiprocessor_survey}: \ca \textit{no migration} (tasks are allocated to a fixed core), \cb \textit{task-level migration} (the jobs of a task may execute on different cores), and \cc \textit{job-level migration} (the jobs of a task migrate to and execute on different core although parallel execution of a job is not permitted). Schedulability tests\cite{res_time_1, res_time_rts,  bini2004schedulability,mutiprocessor_survey} are used to determine
if all tasks in the system meet their respective deadlines. If this is the
case, then the task set is deemed to be \textit{``schedulable''} and the system, \textit{safe}.



%\input{project_description/se_task_table}
%The focus of this research is on integrating or retrofitting security mechanisms into RTS.  When integrating any security mechanisms into RTS, the designers need to ensure that they do not perturb or impact the real-time functions in any significant way while at the same time provide the necessary level of security. This is especially acute in the case of \textit{legacy systems} (\ie existing RTS where modification or perturbation of task parameters such as run-times, periods, and task execution orders is not always feasible.) Any security mechanisms that are introduced not only have to co-exist with existing real-time tasks without violating their real-time and safety constraints but also the {\em parameters of such legacy tasks cannot be adjusted to accommodate the security tasks.}  Not only must the security mechanisms work effectively but they must also not interfere with the deadlines of real-time tasks. For instance, any monitoring and detection mechanism has to be designed so that an adversary cannot easily evade it. This may require that the monitoring and detection tasks be run \textit{frequently}. However, the stringent timing constraints in hard RTS introduce additional complexities for the implementation of such cyber-security mechanisms. For instance, the strict deadlines for the completion of periodic real-time tasks may not allow for frequent execution of security mechanisms. Further, unlike in conventional computing systems, it may not be possible to execute the security mechanisms for arbitrary lengths of time. The challenge is then, how do we develop solutions that address the apparent tension between \textit{security requirements} (\ie having enough cycles for effective monitoring detection) and the \textit{timing and safety requirements} (\ie not interfere with deadlines)?
%
%
%Hence, we propose to improve the security posture of RTS through integration of \textit{\textbf{``security tasks''}} (\ie tasks that are specific for intrusion monitoring and detection purposes) while ensuring that the existing real-time tasks are \textit{not affected} by such integration. Table~\ref{table:rtos} presents some examples of security tasks that can be integrated into legacy systems.  Security tasks could include protection, detection or response mechanisms, depending on the system requirements --- for instance, a sensor correlation task (to detect sensor manipulation) or an anomaly detection task (that checks possible intrusions)~\cite{caml_song2016}. 
%%\textbf{Note:} 
%%Table~\ref{table:rtos} is by no stretch meant to be an exhaustive list. 
%Our proposed work will \textit{not} design towards any specific security mechanisms --- our focus here is to \textit{integrate any designer-provided security monitoring tasks} and \textit{schedule} them with respect to real-time constraints into a multicore RTS.

\paragraph{Related and Complementary Work.}

Enhancing security in real-time applications is an active research area (see the related surveys~\cite{mhasan_rtiot_sensors19,chai2019short}). There exists some work
\cite{xie2007improving,lin2009static,lesi2017network,lesi2017security,sg1,sg2,sibin_RT_security_journal, zhang2013design, jiang2013optimization, taskshuffler, mhasan_reorder_tech_report, hamad2018prediction, schedguard_rtas21} on reconciling the addition of
security mechanisms into RTS. However, they are designed for single-core platforms only, and unlike ours, they require modification of the existing real-time tasks. Researchers also proposed architectural frameworks~\cite{securecore, securecore_memory, securecore_syscal, mohan_s3a, slack_cornell, mhasan_resecure_iot} that use hardware/software mechanisms to
protect against security vulnerabilities. However, those frameworks require custom hardware support for monitoring and are not suitable for legacy or off-the-shelf systems. Integrating monitoring and detection tasks for multicore RTS without custom hardware support is an open research problem. There also exist a large number of work for generic cyber-physical/IoT-specific embedded systems (too many to enumerate here, refer to  the related surveys%~\cite{ammar2018internet, trustzone_survey}) 
~\cite{cps_security_sruvey_iot,yang2017survey, ammar2018internet, trustzone_survey, trustzone_survey_2}) 
--- however, considering real-time security aspects distinguishes proposed work from other research. 


\section{Integrating Monitoring and Detection} \label{sec:prior_work}

%\paragraph{Considerations for Integrating Security Tasks.}  

To begin with, we propose the following two performance criteria for integrating security tasks. %into RTS.

\textit{\textbf{-- Monitoring Frequency:}} Recall from our earlier discussion (Section~\ref{sec:background}) that application tasks in RTS are periodic (\ie they follow a fixed inter-arrival pattern) and scheduled by a priority-driven order. To provide the best protection, the security tasks need to be executed quite often (\ie smaller inter-arrival duration). On the one hand, if the interval between consecutive monitoring events is too large, the adversary may harm the system (and remain undetected) between two invocations of the security task. On the other hand, if the security tasks are executed very frequently, it may impact the schedulability of the real-time tasks. Herein lies an important \textit{trade-off} between \textit{monitoring frequency} and \textit{schedulability}. 

\textit{\textbf{-- Responsiveness:}} In some circumstances, a security task may need to execute with less interference (\ie interruptions) from higher-priority tasks. For instance, consider the scenario where a security breach is suspected. In such an event the security task may be required to \textit{perform more fine-grained checking instead of waiting for its next periodic slot}. This may result in delayed execution of low-priority, non-critical, real-time tasks.
However, the scheduling policy must ensure that the system remains secure without violating real-time constraints for critical, high-priority, real-time tasks. 

%\begin{enumerate}[leftmargin=0.2in]
%	\item \textit{Monitoring Frequency:} In order to provide the best protection, the security tasks need to be executed quite often. On the one hand, if the interval between consecutive monitoring events is too large, the adversary may harm the system (and remain undetected) between two invocations of the security task. On the other hand, if the security tasks are executed very frequently then it may impact the schedulability of the real-time tasks. Herein lies an important \textit{trade-off} between \textit{monitoring frequency} and \textit{schedulability}. 
%	
%	\item \textit{Responsiveness:} In some circumstances, a security task may need to execute with less interference from higher-priority tasks. For instance, consider the scenario where a security breach is suspected. In such an event the security task may be required to \textit{perform more fine-grained checking instead of waiting for its next periodic slot}. This may result in delayed execution of low-priority, non-critical, real-time tasks.
%	However, the scheduling policy needs to ensure that the system remains secure without violating real-time constraints for critical, high-priority, real-time tasks. 
%	
%	%	\item \textit{Atomicity:} Depending on the operation, some of the security tasks may need to be executed \textit{without preemption}. For instance, let us consider a security task that scans the process table and has been preempted in the middle of its operation. An adversary may corrupt the process table entry that has already been scanned before the next scheduling point of the security task. When the security tasks are rescheduled, it will start scanning from its last known state and may not be able to detect the changes in a timely manner.  
%\end{enumerate}

%Unlike single core systems, integrating security into multicore platforms is more challenging since designers have multiple choices across cores to retrofit security mechanisms. 

One may wonder why we cannot schedule the security tasks in the same way that the existing real-time tasks are scheduled. However, without careful schedulability
analysis, if we set arbitrary high-priority or small inter-arrival duration, this may violate timing constraints for the critical real-time tasks --- thus, the main safety requirements of the system will be threatened~\cite{sibin_deeply}.  Unlike single-core systems, integrating security into multicore platforms is more challenging since the designers now have multiple choices for allocating the security tasks. For instance, should the engineers: 
\ci \textit{dedicate a core} to all the security tasks; or 
\cii \textit{spread the security tasks to all cores} (in conjunction with the real-time tasks) and if so, how to determine the \textit{task-to-core assignment}? or \ciii \textit{execute them continuously} across any available core? In addition, how can the designers \textit{determine the monitoring frequency of security tasks}? How do we develop a \textit{reactive framework that dynamically adjusts security tasks into available cores for better responsiveness upon suspicion of a security breach?} These are themselves critical research challenges that need to be investigated.



\paragraph{Adversary Model.}

We assume that an adversary may destabilize the system by leveraging (known) vulnerabilities. 
%For example, an attacker could compromise the file system (resulting in corrupted information/system log), change the of control/actuation commands or infer side-channel information (\eg user tasks, cache, thermal profiles) to launch further attacks (\eg denial of service). 
%While there exists mechanisms (such as Simplex~\cite{sha2001using,l1_simplex}) that guarantee (hardware/software) fault tolerance, I consider the cases where an attacker intentionally induces faults (\ie adversarial artifacts) that may jeopardize the safety of the system (\eg results in miss deadlines). 
Our focus is on threats that can be dealt with by \textit{integrating additional security tasks} into the host (see Table~\ref{table:rtos} for related examples). The addition of such tasks may necessitate changing the schedule or increasing the execution time of real-time tasks, as was the case in earlier work~\cite{sibin_RT_security_journal,sg1, sg1, lin2009static,xie2007improving, zhang2013design, jiang2013optimization}.  In this research, we consider situations where additional security tasks  are only allowed to have no (or minimal) impact on the schedule of existing real-time tasks and are not allowed to modify real-time parameters. We note that the design of integration techniques and the design of the specific security tasks are orthogonal problems, and our proposed methods are agnostic to the particular monitoring mechanism. 

%Since we aim to maximize the frequency of execution of security tasks, mechanisms whose performance improves with frequency of execution (\eg intrusion monitoring and detection tasks or logging/tracing mechanisms) benefit from my model.



%For instance,is it better to \textit{dedicate a core} to all the security tasks or is it better to \textit{spread them out} (in conjunction with the real-time tasks) and if so, to \textit{which cores}? It is not trivial to determine the execution frequency and core assignment of security mechanisms (\ie \textit{what} security tasks will execute on \textit{which core} and with \textit{what frequency}). This in itself a research challenge that needs to be investigated.

%\paragraph{Preliminary Work: Contego~\cite{mhasan_rtss16, mhasan_ecrts17} and Hydra~\cite{mhasan_date18, mhasan_date20}.}

\paragraph{Preliminary Work.}

The PI's dissertation work~\cite{mhasan_rtss16, mhasan_ecrts17, mhasan_date18, mhasan_date20} provides the foundation of this research. 
%In early work~\cite{mhasan_rtss16}
%we proposed a framework for single core systems that allows the execution of
%security tasks \textit{``opportunistically'' in conjunction with real-time
%	tasks, while keeping the best possible periods for the security tasks that
%	ensure all the tasks in the system remain schedulable}. In particular, we propose to execute security tasks \textit{opportunistically}, that is, with the lowest priority so that real-time tasks are not affected. We measured the security of the system by means of the \textit{achievable
%	periodic monitoring}. Let $T_i$ be the period of the security task $\tau_i \in
%\Gamma_S$ that needs to be determined. Since our goal was to minimize the
%perturbation between the achievable period $T_i$ and the desired period
%$T_i^{des}$, we define the following metric: 
%%\begin{equation}\label{eq:metric}
%$\eta_i = \frac{T_i^{des}}{T_i}$
%%\end{equation}
%that denotes the \textit{tightness} of the frequency of periodic monitoring for
%the security task $\tau_i$. Thus $\eta =  \sum_{\tau_i \in \Gamma_S}
%\omega_i \eta_i$ denotes the \textit{cumulative tightness} of the achievable
%periodic monitoring where $\omega_i $ are given weights. Our proposed  metric provides one way to trade-off security with
%schedulability --- if the interval between consecutive monitoring
%events is too large, an adversary may remain undetected and harm the system
%between two invocations of the security task; but, a very
%frequent execution of security tasks may impact the schedulability of the
%real-time tasks. Hence, $\eta$ allows us to execute security
%routines with a frequency closer to the desired one while respecting the
%temporal constraints of the other real-time tasks.
In early work~\cite{mhasan_rtss16} we introduce a technique that allows the execution of security tasks \textit{``opportunistically'' with the lowest-priority} in conjunction with real-time
tasks (so that they do not interfere with the execution order of real-time tasks), while keeping the best possible periods (\ie monitoring frequency) for the security tasks. However, we find that when security tasks always execute with the lowest priority, they suffer more interference (\ie preemption from high-priority real-time tasks), and the longer detection time (due to poor response time) makes the security mechanisms less effective. To provide better responsiveness and increase the effectiveness of monitoring and detection mechanisms, we then propose a \textit{dual-mode framework}~\cite{mhasan_ecrts17}
%For the most part, CONTEGO executes in a PASSIVE mode (i.e., with opportunistic execution of intrusion detection tasks). However, CONTEGO will switch to an ACTIVE mode of operation to perform additional checks as needed (e.g., fine-grained analysis, used as an example in Section 4.7.2). This ACTIVE mode potentially executes with higher priority, while ensuring the timing guarantees of real-time tasks.
 %I then propose a dual-mode model (named CONTEGO) 
 that allows the security tasks to execute in two different modes: \ca by default, security tasks execute opportunistically when the system is deemed to be uncompromised (PASSIVE mode); \cb if an anomaly is suspected, the security tasks may switch to a higher priority (while ensuring the timing guarantees of real-time tasks) to perform additional checks as needed (ACTIVE mode); \cc the system reverts to PASSIVE mode if: \ci no anomalous activity is found or \cii the root cause of the problem is detected, and malicious entities are removed. We also devise a \textit{metric} (called \textit{``tightness of monitoring''}) that allows us to execute security tasks with a frequency closer to the designers' expectations and provides us one way to trade-off security with schedulability. 
 
 %We evaluate our ideas technique using time-to-detect an intrusion as a performance criteria with a view to observing how well the security tasks can perform desired monitoring and detection after period selection.


 

%Unlike single core systems, integrating security into multicore platforms is more challenging since the designers now have multiple choices for where to allocate the security tasks. For instance, should the engineers: 
%%\ci \textit{dedicate a core} to all the security tasks; or 
%\ci \textit{spread the security tasks to all cores} (in conjunction with the real-time tasks) and if so, how to determine the \textit{task-to-core assignment}? or \ciii \textit{execute them continuously} across any available core? In addition, how the designers can \textit{determine the periods of the security tasks}?
%Chapter~\ref{ch:hydra-c} addresses aforementioned issues. 


The above frameworks are designed for single-core platforms. In the follow-up work~\cite{mhasan_date18}, we first develop
a low-complexity iterative solution that
jointly finds the security tasksâ€™ periods and core assignments where the security tasks are \textit{statically assigned} across all available cores. 
%I compare \coolnameplus with another scheme that allocates a dedicated core for security tasks while the real-time tasks are assigned to the remaining cores. I find out on average, \coolnameplus can provide 27.23\% faster intrusion detection rate (on a quad core system) when compared to the other scheme. 
%In Chapter~\ref{ch:hydra-c} 
We then introduce an alternate design mechanism~\cite{ mhasan_date20} that \textit{can raise the ``responsiveness'' of monitoring tasks by increasing their frequency of execution}. The fundamental intuition is that if the security tasks can execute with as few interruptions as possible (\eg by moving immediately to an empty core when they are interrupted), then there is a much higher chance of successful detection and hence, a much lower chance of successful adversarial action. The latter scheme provides better monitoring but comes with a cost (in terms of context switch overhead).

