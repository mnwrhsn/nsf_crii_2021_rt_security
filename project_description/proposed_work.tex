%\section{Proposed Work: Multicore Security Integration}
\section{Proposed Work} \label{sec:proposed_work}

\subsection{Reactive Security Mechanisms for Multicore Systems}

%Recall that Contego~\cite{mhasan_ecrts17} is developed for single core systems and multicore security integration frameworks (\eg HYDRA~\cite{mhasan_date18, mhasan_date20}) do not support runtime mode changes upon suspecting security breaches. 

Recall that multicore security integration frameworks introduced in our prior work~\cite{mhasan_date18, mhasan_date20} do not support runtime mode changes upon suspecting security breaches. 
Integrating reactive security mechanisms for legacy multicore platforms (where designers have less flexibility for changing system architecture/parameters) is still an open problem. Our goal is to explore the possible
ways in which security could be integrated into multicore-based real-time platforms. For instance, will the security tasks \textit{always be running} (perhaps on one of the dedicated cores)? Must the security tasks be allowed to \textit{take up more (or all) cores} (\eg switch to ACTIVE mode) as it detects malicious activity?
%A reactive security framework for multicore context is more challenging --- for instance, 
 We 
need to consider various design choices and implementation issues, such as:

\ci Should we take over one core complete to execute security tasks in ACTIVE mode (and perhaps reschedule the real-time tasks to other cores), or use all the cores (or a subset of cores) for security tasks and possibly execute with a higher priority than some of the real-time tasks? How do we determine their periods? How quickly could  the intrusions be detected?

\cii Is it better to design a security task (that monitors continuously) that executes in a particular core (for PASSIVE mode) or move across all cores, if so, does it improve schedulability/security? How can the desired real-time requirements and control system performance be satisfied with mode changes?

\ciii How will the reactive security mechanisms (\ie PASSIVE-to-ACTIVE and vice-versa) be implemented in practice in the RTOS/scheduler? What is the scheduling/context switch overhead of the mode switch? 


To address these issues, we will \ca devise design-time analytical models to ensure that timing guarantees are met and \cb develop necessary APIs, libraries, and OS patches to deploy reactive security protocols into commodity real-time kernels. In particular, we will extend existing multi-mode real-time scheduling techniques~\cite{nelis2009two, yomsi2010scheduling, baek2020response} with security requirements and explore various design alternatives mentioned above.  We will formulate period selection as a constrained optimization problem~\cite{boyd_book} and explore existing tools such as geometric programming models~\cite{GP_tutorial} to solve them. As mentioned earlier, the development of our proposed reactive monitoring framework also requires system-level modifications. 
%Applications developers have to be cognizant of the underlying properties of such a security-aware framework and also be provided access to an API that can enable them to take advantage of it. The RTOS and TrustZone APIs that are running on the embedded devices have to be redesigned with real-time security requirements in mind --- 
For instance, 
the scheduler must supports dynamic mode changes (with bounded latency) when it receives a signal from the corresponding security tasks. As part of our research, we will modify existing open-source RTOS schedulers (RT\_PREEMPT Linux~\cite{rt_patch} and LITMUS\textsuperscript{RT}~\cite{litmus_rt}) and provide support for continuous monitoring and dynamic mode changes.
%\footnote{We discuss this topic further in Section~\ref{sec:sys_api}.} 

%and leverage the ideas introduces in our prior work~\cite{mhasan_ecrts17} to address the aforementioned design choices. 
%
%While there exists work~\cite{nelis2009two} dealing with multiple mode tasks in conventional RTS, casting security requirements (similar to ones that mentioned above) into existing real-time scheduling problems require further study. We also need to modify the RTOS scheduler to provide support for continuous monitoring and dynamic mode changes. We will explore these issues as part of our research. 

\subsection{Atomicity and Task Dependency}

Once we have developed the above reactive security mechanism for multicore RTS, we will extend our framework to \ca allow atomic (\ie non-preemptive) operations and \cb support inter-dependent execution.
Security tasks so far have been treated as being independent and preemptive. Some security tasks may need to be executed \textit{without preemption} (\ie atomic event) depending on the operation. For example, consider a security task that scans the process table and has been preempted in the middle of its operation. An adversary may corrupt the process table entry that has already been scanned before the next scheduling point of the security task. When the security task is rescheduled, it will start scanning from its last known state and may not be able to detect the changes on time. One way to support such a case is the following. When any security task needs to perform special atomic operations, the priority of the tasks can be increased to one that is strictly higher than all (or some) of the real-time tasks, depending on the requirements of the checking event. However, such atomic operations (using priority inversions) may compromise the timing constraints of some (or all!) of the real-time tasks. Hence, schedulability analysis needs to consider this. Besides, the scheduling policy should identify which real-time or security tasks can be dropped (or perhaps reschedule to other cores) to provide a better trade-off between real-time performance and security defense.

 Further, security tasks may have dependencies where one task depends on the output from one or more other tasks (\ie they may need to follow certain \textit{precedence constraints}). For example, an anomaly detection task may depend on the outputs of multiple scanning tasks. 
 %Or, the scheduling framework may need to follow certain \textit{precedence constraints} for security tasks. For example, in order to ensure integrity of monitoring security, the security tasks' own binary may need to be examined first before checking the system binary files. 
 In such cases, we may not independently execute the security tasks in parallel into multiple cores. To address this, 
 %we will consider the problem of integrating security tasks with dependencies between them. In particular, 
 %we proposed to
 we will use a directed acyclic graph (DAG) to capture the dependencies and constraints among security tasks.
 % and explore scheduling techniques for DAG-based tasksets. %tasksets to integrate such tasks into real-time systems. 
 In this case, the ``tightness'' metric used in our earlier work~\cite{mhasan_rtss16,mhasan_ecrts17,mhasan_date18,mhasan_date20} (see Section~\ref{sec:prior_work}) may no longer be a reasonable metric. We will include the constraints to ensure that the entire DAG is executed often and study what metrics can better capture security dependency requirements. 
 
 %\todo{fine-tune!}
 % and evaluate with different metrics that captures such dependecny re.

%\subsection{Extension for Dynamic Priority Systems}
%
%Our preliminary work is designed for fixed-priority schedulers since they are commonly used in commercial systems. However there exist dynamic scheduling algorithms (\eg EDF and LL?) that provide higher schedulability bounds.  Such dynamic scheduling algorithms can potentially increase the capacities of our proposed security integration frameworks  and eventually provide better tightness of monitoring for the security tasks. Integrating security mechanisms using dynamic scheduling algorithm such as EDF~\cite{?}, however, requires further analysis due to run-time priority changes of the real-time and the security tasks. In particular, the opportunistic sporadic security task model may need to updated with an objective of reducing the average response time and provide better tightness of periodic monitoring without compromising the schedulability of real-time tasks. We also intend to instrumenting those mechanisms in a commodity real-time OS with dynamic scheduler (say \texttt{SCHED\_DEADLINE} in real-time Linux kernel~\cite{?}) and investigate that whether the security mechanisms are operated as those are intended to.Besides, it requires further investigation to determine whether this improved system utilization (at the cost of analysis/implementation overhead) can provide us additional security benefits.
 

\subsection{Security Metrics and Performance Evaluation} 

In preliminary work, \cite{mhasan_rtss16,mhasan_ecrts17,mhasan_date18,mhasan_date20}  we tested \textit{time-to-detect an intrusion} as a
performance metric to observe how
well the security tasks can perform desired monitoring and detection after
period adaptation. But how do we know that this trade-off framework works well in
practice? How do we know the efficient design choices (say  core-to-task assign strategy)? What are the \textit{right metrics}
to measure the performance of the multicore system? We need a way to measure the system
performance and a systematic way of exploring the design-space.    While \textit{time-to-detect} is a valuable metric, it is hard to quantify comprehensively as it depends on several factors (such as the efficacy
of monitoring tasks, the kind of intrusion) and is a lagging metric. Apart from security metrics, it is also necessary to understand the impact of adding security on real-time timing properties to verify that the system functionality has not been impaired.  For instance, albeit for a limited time, the dynamic mode switching may reduce utilization (especially for some low-priority real-time tasks in the ACTIVE mode). Hence, this \textit{difference in utilization} can be used as a metric to measure the cost of security. Identifying and designing better metrics is an important and challenging problem. 
 We will undertake it in the narrow context of integrating security tasks into multicore RTS.  

%We will undertake it in the narrow context of integrating monitoring and detection tasks into multicore RTS.  





%\todo{check Sibin CAREER Page 12/13}

\subsection{Bringing it Together: Secure Hardware-Software Integration} \label{sec:sys_api}



The algorithms and mechanisms discussed thus far must be implemented as software components that run on the multicore platform. There is also a requirement that security tasks are executed in tamper-resistance space such that an adversary cannot easily evade the  detection mechanisms. If the security tasks are infiltrated, or cannot be scheduled, no matter how effective the original algorithms are, we cannot guarantee the security of the system. One challenge is: \textit{what are the minimum components that must be provided with the isolation mechanisms?} Even if the various components are carrying out their expected functionality, the security of the systems might be jeopardized if the underlying execution platforms (hardware and OS) are unable to protect security tasks from malicious actions. Hence, security tasks require \textit{isolation guarantees} --- to prevent tampering, and there is a need for trusted execution environments (TEEs)~\cite{7345265_tee} to ensure the integrity and trustworthiness of the overall system. Hence, we propose to use an off-the-shelf trusted module (\ie ARM TrustZone~\cite{trustzone_survey,trustzone_survey_2}) to ensure tamper-proof execution of security tasks.\footnote{Considering the short time frame of this project, we limit our study to TrustZone-based enclaves. 
%We will explore other TEE architectures such as Intel SGX~\cite{intel_sgx} and RISC-V MultiZone~\cite{risc_v_multizone} in the future. 
However, our ideas are general and can be adapted to other TEE architectures such as Intel SGX~\cite{intel_sgx} and RISC-V MultiZone~\cite{risc_v_multizone}.} Since vanilla TrustZone is not designed for real-time applications, we need algorithms and techniques to ensure that security tasks comply with real-time requirements when they execute within the trusted enclaves. For instance, the scheduler and context switch overhead of  TrustZone enclaves need to be bounded to ensure that timing constraints are not violated. In the proposed research, we will develop \textit{design-time schedulability models} that will analytically guarantee that the timing constraints are satisfied. We will further develop \textit{a secure OS-level interface} based on commodity open-source real-time kernels (RT\_PREEMPT Linux~\cite{rt_patch} and LITMUS\textsuperscript{RT}~\cite{litmus_rt}) and OP-TEE~\cite{optee} TrustZone ports. 
Our schedulability tests, scheduler plugins, and OS-level mechanisms will ensure that security tasks are executed in a tamper-proof environment (TrustZone enclaves) and carried out their desired functionalities while retaining real-time guarantees. In prior work~\cite{mhasan_resecure_iot, mhasan_iotsnp19}, we \textit{successfully used off-the-shelf trusted modules} in multiple cyber-physical use-cases --- we will leverage our expertise on TEEs in the proposed research. We will \textit{open-source our implementation and release the APIs} for community use.

%The development of a security-aware framework for multicore RTS also requires system-level modifications. Applications developers have to be cognizant of the underlying properties of such a security-aware framework and also be provided access to an API that can enable them to take advantage of it. The RTOS and TrustZone APIs that are running on the embedded devices have to be redesigned with real-time security requirements in mind --- for instance, the scheduler need to support for dynamic mode changes when it receives signal from corresponding security tasks. Besides, the scheduler and context switch overhead of mode change at the OS and TrustZone enclaves need to be bounded to ensure that timing constrains are not violated.  In the proposed research we will develop \textit{a secure OS-level interface} based on commodity open-source real-time kernels (RT\_PREEMPT Linux~\cite{rt_patch} and LITMUS\textsuperscript{RT}~\cite{litmus_rt}) and OP-TEE~\cite{optee} TrustZone ports. 
%%In particular, as a part of this project we intend to \ca develop suitable APIs and scheduler plug-ins 
%%%that allows designers to select different schedulers (\eg fixed and dynamic priority) as well as 
%%to provide support for reactive security mechanisms (\eg mode changes); \cb enable support for OS-level mechanisms to ensure that security tasks are executed in a tamper-proof environment (TrustZone enclaves) such that security checks are enforced runtime. 
%Our scheduler plug-ins and OS-level mechanisms will ensure that security tasks are executed in a tamper-proof environment (TrustZone enclaves) and carried out their desired functionalities. %and performed required checks at runtime.
%We will \textit{open-source our implementation and release the APIs} for community use.



\vspace*{0.2em}
\begin{mdframed}[backgroundcolor=gray!10]
\vspace{-1.2em}
\hfill{}\fcolorbox{black}{gray!30}{\bf Research Tasks}\hfill{}

\begin{itemize}[leftmargin=*]
	\parskip 0pt
	\itemsep 0pt
	\item \rtask Extend multi-mode framework for multicore RTS --- this includes: \ca design-space exploration of multiple mode-switch alternatives, \cb integrate with multicore RTOS schedulers, and \cc analyze the efficacy of each of the techniques.
	\item \rtask Design frameworks for methodically integrating reactive monitoring and detection mechanisms for multi-core RTS with non-preemptive execution and precedence constraints.
	\item \rtask ~\ca Explore different performance metrics and evaluate their efficacy;~\cb Study whether new metrics can provide additional real-time/security insights.
%	\item \rtask Blah
	\item \rtask ~\ca Retrofit TrustZone technology for the real-time security integration frameworks --- this includes the development of new frameworks, algorithms, and schedulability analysis as well as necessary system-level modifications; \cb Develop necessary APIs and integrate them with existing real-time kernels; \cc Prepare necessary documentation for open-source release.
\end{itemize}
\end{mdframed}